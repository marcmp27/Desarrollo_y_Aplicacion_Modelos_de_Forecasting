---
title: "TFG"
author: "Marc Muñoz Pi (1570951)"
date: "11/12/2022"
output:
  html_document:
    df_print: paged
---

```{r Librerias, warning=FALSE, message=FALSE, include=FALSE}
#install.packages("parallel");install.packages("mlogit");install.packages("dplyr");install.packages("forecast")
#install.packages("fpp2");install.packages("vars");install.packages("broom");install.packages("kableExtra")
#install.packages("nlme");install.packages("lmtest");install.packages("mFilter");install.packages("dynlm")
#install.packages("knitr");install.packages("stats");install.packages("quantmod");install.packages("tseries")
#install.packages("tidyquant");install.packages("tidyverse");install.packages("highcharter");install.packages("car")
#install.packages("astsa");install.packages("foreign");install.packages("timsac");install.packages("readxl")
#install.packages("MASS");install.packages("BBmisc");install.packages("FinCal");install.packages("conf")
#install.packages("gridExtra");install.packages("PerformanceAnalytics");install.packages("corrplot");install.packages("graphics")
#install.packages("timetk");install.packages("seasonal");install.packages("vctrs");install.packages("pipeR")
#install.packages("cli");install.packages("skimr");install.packages("TSstudio");install.packages("fpp")
#install.packages("ggplot2");install.packages("lubridate");install.packages("TSA");install.packages("Spectrum")
#install.packages("rugarch");install.packages("GARCHSK");install.packages("garchx")

library(parallel);library(mlogit);library(dplyr);library(tidyr);library(forecast);library(fpp2);library(vars);library(mFilter);library(dynlm);library(nlme);library(lmtest);library(broom);library(kableExtra);library(knitr);library(stats);library(quantmod);library(tseries);library(tidyquant);library(tidyverse);library(highcharter);library(car);library(astsa);library(foreign);library(timsac);library(readxl);library(MASS);library(BBmisc);library(FinCal);library(conf);library(gridExtra);library(PerformanceAnalytics);library(corrplot);library(graphics);library(timetk);library(seasonal);library(vctrs);library(pipeR);library(cli);library(skimr);library(TSstudio);library(fpp);library(ggplot2);library(lubridate);library(TSA);library(Spectrum);library(rugarch);library(GARCHSK);library(garchx);library(quantmod);library(lattice);library(timeSeries);library(rugarch)
```

###########################################################################
OBTENCIÓN DE LOS DATOS, CREACIÓN Y TRATAMIENTO DE VARIABLES 
###########################################################################

```{r Datos SP, warning=FALSE, echo=FALSE}

###########################################################################
#SP500 Stock Exchange
###########################################################################

mdate="2000-01-01"
BBDD_SP500 <-getSymbols('^GSPC', from=mdate, auto.assign = F)
BBDD_SP500 <- na.omit(BBDD_SP500)
chartSeries(BBDD_SP500, name = "BBDD_SP500 Price Evolution")
Returns_SP <- CalculateReturns(BBDD_SP500$GSPC.Adjusted);Returns_SP <- Returns_SP[-c(1),]

BBDD_SP500 <- as.matrix(BBDD_SP500)
Date <- rownames(BBDD_SP500)
BBDD_SP500<-as.data.frame(BBDD_SP500)
BBDD_SP500$Date<-Date
rownames(BBDD_SP500)<- NULL
BBDD_SP500$Date <- as.Date(BBDD_SP500$Date)
Semester <- semester(BBDD_SP500$Date)
Month <- month(BBDD_SP500$Date)
Quarter <- quarter(BBDD_SP500$Date)

Profit_SP <- c(BBDD_SP500$GSPC.Adjusted-BBDD_SP500$GSPC.Open)
Variabilitat_SP <- c(BBDD_SP500$GSPC.High-BBDD_SP500$GSPC.Low)

SP500_prices <- BBDD_SP500[, "GSPC.Adjusted", drop = FALSE];n <- nrow(SP500_prices)
Return_SP <- ((SP500_prices[2:n, 1] - SP500_prices[1:(n-1), 1])/SP500_prices[1:(n-1), 1])
Return_SP <- as.data.frame(Return_SP);Return_SP <- rbind(0, Return_SP)

BBDD_SP500 <- as.matrix(BBDD_SP500);BBDD_SP500 <- cbind(BBDD_SP500,Semester,Quarter,Month, Profit_SP, Variabilitat_SP, Return_SP);BBDD_SP500 <- as.data.frame(BBDD_SP500)
BBDD_SP500$Date <- as.Date(BBDD_SP500$Date)

BBDD_SP500$Profit_SP <- as.numeric(BBDD_SP500$Profit_SP)
BBDD_SP500$GSPC.Open <- as.numeric(BBDD_SP500$GSPC.Open)
BBDD_SP500$GSPC.High <- as.numeric(BBDD_SP500$GSPC.High)
BBDD_SP500$GSPC.Low <- as.numeric(BBDD_SP500$GSPC.Low)
BBDD_SP500$GSPC.Close <- as.numeric(BBDD_SP500$GSPC.Close)
BBDD_SP500$GSPC.Volume <- as.numeric(BBDD_SP500$GSPC.Volume)
BBDD_SP500$GSPC.Adjusted <- as.numeric(BBDD_SP500$GSPC.Adjusted)
BBDD_SP500$Variabilitat_SP <- as.numeric(BBDD_SP500$Variabilitat_SP)

SP500_Time_Series <- ts(BBDD_SP500$GSPC.Adjusted, start = 2000, frequency = 365)
View(BBDD_SP500)
```

```{r Datos DAX, warning=FALSE, echo=FALSE}

###########################################################################
#Dax Stock Exchange
###########################################################################

BBDD_DAX <-getSymbols('^GDAXI', from=mdate, auto.assign = F)
BBDD_DAX <- na.omit(BBDD_DAX)
chartSeries(BBDD_DAX, name = "BBDD_DAX Price Evolution")
BBDD_DAX <- BBDD_DAX[-1,];BBDD_DAX <- BBDD_DAX[-1,]
Returns_DAX <- CalculateReturns(BBDD_DAX$GDAXI.Adjusted);Returns_DAX <- Returns_DAX[-c(1),]

BBDD_DAX <- as.matrix(BBDD_DAX)
Date <- rownames(BBDD_DAX)
BBDD_DAX<-as.data.frame(BBDD_DAX)
BBDD_DAX$Date<-Date
rownames(BBDD_DAX)<- NULL
BBDD_DAX$Date <- as.Date(BBDD_DAX$Date)

Semester <- semester(BBDD_DAX$Date)
Month <- month(BBDD_DAX$Date)
Quarter <- quarter(BBDD_DAX$Date)
Profit_Dax <- c(BBDD_DAX$GDAXI.Adjusted-BBDD_DAX$GDAXI.Open)
Variabilitat_Dax <- c(BBDD_DAX$GDAXI.High-BBDD_DAX$GDAXI.Low)
Returns_Dax <- c(((Profit_Dax)/BBDD_DAX$GDAXI.Open)*100)

Dax_prices <- BBDD_DAX[, "GDAXI.Adjusted", drop = FALSE];n <- nrow(Dax_prices)
Return_Dax <- ((Dax_prices[2:n, 1] - Dax_prices[1:(n-1), 1])/Dax_prices[1:(n-1), 1])
Return_Dax <- as.data.frame(Return_Dax);Return_Dax <- rbind(0, Return_Dax)

BBDD_DAX <- as.matrix(BBDD_DAX);BBDD_DAX <- cbind(BBDD_DAX,Semester,Quarter,Month, Profit_Dax, Variabilitat_Dax, Return_Dax);BBDD_DAX <- as.data.frame(BBDD_DAX)
BBDD_DAX$Date <- as.Date(BBDD_DAX$Date)

BBDD_DAX$Profit_Dax <- as.numeric(BBDD_DAX$Profit_Dax)
BBDD_DAX$GDAXI.Open  <- as.numeric(BBDD_DAX$GDAXI.Open)
BBDD_DAX$GDAXI.High <- as.numeric(BBDD_DAX$GDAXI.High)
BBDD_DAX$GDAXI.Low <- as.numeric(BBDD_DAX$GDAXI.Low)
BBDD_DAX$GDAXI.Close <- as.numeric(BBDD_DAX$GDAXI.Close)
BBDD_DAX$GDAXI.Volume <- as.numeric(BBDD_DAX$GDAXI.Volume)
BBDD_DAX$GDAXI.Adjusted <- as.numeric(BBDD_DAX$GDAXI.Adjusted)
BBDD_DAX$Variabilitat_Dax <- as.numeric(BBDD_DAX$Variabilitat_Dax)

DAX_Time_Series <- ts(BBDD_DAX$GDAXI.Adjusted, start = 2000, frequency = 365)
```

```{r Datos HK, warning=FALSE, echo=FALSE}

###########################################################################
#Hong Kong Stock Exchange
###########################################################################

BBDD_HongKongSE <-getSymbols('^HSI', from=mdate, auto.assign = F)
BBDD_HongKongSE <- na.omit(BBDD_HongKongSE)
chartSeries(BBDD_HongKongSE, name = "HongKongSE Price Evolution")
Returns_HK <- CalculateReturns(BBDD_HongKongSE$HSI.Adjusted);Returns_HK <- Returns_HK[-c(1),]

BBDD_HongKongSE <- as.matrix(BBDD_HongKongSE)
Date <- rownames(BBDD_HongKongSE)
BBDD_HongKongSE<-as.data.frame(BBDD_HongKongSE)
BBDD_HongKongSE$Date<-Date
rownames(BBDD_HongKongSE)<- NULL
BBDD_HongKongSE$Date <- as.Date(BBDD_HongKongSE$Date)

Semester <- semester(BBDD_HongKongSE$Date)
Month <- month(BBDD_HongKongSE$Date)
Quarter <- quarter(BBDD_HongKongSE$Date)
Profit_HK <- c(BBDD_HongKongSE$HSI.Adjusted-BBDD_HongKongSE$HSI.Open)
Variabilitat_HK <- c(BBDD_HongKongSE$HSI.High-BBDD_HongKongSE$HSI.Low)

HK_prices <- BBDD_HongKongSE[, "HSI.Adjusted", drop = FALSE];n <- nrow(HK_prices)
Return_HK <- ((HK_prices[2:n, 1] - HK_prices[1:(n-1), 1])/HK_prices[1:(n-1), 1])
Return_HK <- as.data.frame(Return_HK);Return_HK <- rbind(0, Return_HK)

BBDD_HongKongSE <- as.matrix(BBDD_HongKongSE);BBDD_HongKongSE <- cbind(BBDD_HongKongSE,Semester,Quarter,Month, Profit_HK, Variabilitat_HK, Return_HK);BBDD_HongKongSE <- as.data.frame(BBDD_HongKongSE)
BBDD_HongKongSE$Date <- as.Date(BBDD_HongKongSE$Date)

BBDD_HongKongSE$Profit_HK <- as.numeric(BBDD_HongKongSE$Profit_HK)
BBDD_HongKongSE$HSI.Open <- as.numeric(BBDD_HongKongSE$HSI.Open)
BBDD_HongKongSE$HSI.High <- as.numeric(BBDD_HongKongSE$HSI.High)
BBDD_HongKongSE$HSI.Low <- as.numeric(BBDD_HongKongSE$HSI.Low)
BBDD_HongKongSE$HSI.Close <- as.numeric(BBDD_HongKongSE$HSI.Close)
BBDD_HongKongSE$HSI.Volume <- as.numeric(BBDD_HongKongSE$HSI.Volume)
BBDD_HongKongSE$HSI.Adjusted <- as.numeric(BBDD_HongKongSE$HSI.Adjusted)
BBDD_HongKongSE$Variabilitat_HK <- as.numeric(BBDD_HongKongSE$Variabilitat_HK)

HongKongSE_Time_Series <- ts(BBDD_HongKongSE$HSI.Adjusted, start = 2000, frequency = 365)
```

```{r Datos OIL, warning=FALSE, echo=FALSE}

###########################################################################
#Crude Oil
###########################################################################

BBDD_Crude_Oil<- getSymbols('CL=F', from=mdate, auto.assign = F)
BBDD_Crude_Oil <- na.omit(BBDD_Crude_Oil)
chartSeries(BBDD_Crude_Oil, name = "Crude_Oil Price Evolution")
Returns_Oil <- CalculateReturns(BBDD_Crude_Oil$`CL=F.Adjusted`);Returns_Oil <- Returns_Oil[-c(1),]

BBDD_Crude_Oil <- as.matrix(BBDD_Crude_Oil)
Date <- rownames(BBDD_Crude_Oil)
BBDD_Crude_Oil<-as.data.frame(BBDD_Crude_Oil)
BBDD_Crude_Oil$Date<-Date
rownames(BBDD_Crude_Oil)<- NULL
BBDD_Crude_Oil$Date <- as.Date(BBDD_Crude_Oil$Date)

Semester <- semester(BBDD_Crude_Oil$Date)
Month <- month(BBDD_Crude_Oil$Date)
Quarter <- quarter(BBDD_Crude_Oil$Date)
Profit_Crude_Oil <- c(BBDD_Crude_Oil$`CL=F.Adjusted`-BBDD_Crude_Oil$`CL=F.Open`)
Variabilitat_Crude_Oil <- c(BBDD_Crude_Oil$`CL=F.High`-BBDD_Crude_Oil$`CL=F.Low`)

Oil_prices <- BBDD_Crude_Oil[, "CL=F.Adjusted", drop = FALSE];n <- nrow(Oil_prices)
Return_Oil <- ((Oil_prices[2:n, 1] - Oil_prices[1:(n-1), 1])/Oil_prices[1:(n-1), 1])
Return_Oil <- as.data.frame(Return_Oil);Return_Oil <- rbind(0, Return_Oil)

BBDD_Crude_Oil <- as.matrix(BBDD_Crude_Oil);BBDD_Crude_Oil <- cbind(BBDD_Crude_Oil,Semester,Quarter,Month, Profit_Crude_Oil, Variabilitat_Crude_Oil, Return_Oil); BBDD_Crude_Oil <- as.data.frame(BBDD_Crude_Oil)
BBDD_Crude_Oil$Date <- as.Date(BBDD_Crude_Oil$Date)

BBDD_Crude_Oil$Profit_Crude_Oil <- as.numeric(BBDD_Crude_Oil$Profit_Crude_Oil)
BBDD_Crude_Oil$`CL=F.Open` <- as.numeric(BBDD_Crude_Oil$`CL=F.Open`)
BBDD_Crude_Oil$`CL=F.High` <- as.numeric(BBDD_Crude_Oil$`CL=F.High`)
BBDD_Crude_Oil$`CL=F.Low` <- as.numeric(BBDD_Crude_Oil$`CL=F.Low`)
BBDD_Crude_Oil$`CL=F.Close` <- as.numeric(BBDD_Crude_Oil$`CL=F.Close`)
BBDD_Crude_Oil$`CL=F.Volume` <- as.numeric(BBDD_Crude_Oil$`CL=F.Volume`)
BBDD_Crude_Oil$`CL=F.Adjusted` <- as.numeric(BBDD_Crude_Oil$`CL=F.Adjusted`)
BBDD_Crude_Oil$Variabilitat_Crude_Oil <- as.numeric(BBDD_Crude_Oil$Variabilitat_Crude_Oil)

Crude_Oil_Time_Series <- ts(BBDD_Crude_Oil$`CL=F.Adjusted`, start = 2000, frequency = 365)
```

```{r Datos NG, warning=FALSE, echo=FALSE}

###########################################################################
#Natural Gas
###########################################################################

BBDD_Natural_Gas<- getSymbols('NG=F', from=mdate, auto.assign = F)
BBDD_Natural_Gas <- na.omit(BBDD_Natural_Gas)
chartSeries(BBDD_Natural_Gas, name = "Natural_Gas Price Evolution")
Returns_NG <- CalculateReturns(BBDD_Natural_Gas$`NG=F.Adjusted`);Returns_NG <- Returns_NG[-c(1),]

BBDD_Natural_Gas <- as.matrix(BBDD_Natural_Gas)
Date <- rownames(BBDD_Natural_Gas)
BBDD_Natural_Gas<-as.data.frame(BBDD_Natural_Gas)
BBDD_Natural_Gas$Date<-Date
rownames(BBDD_Natural_Gas)<- NULL
BBDD_Natural_Gas$Date <- as.Date(BBDD_Natural_Gas$Date)

Semester <- semester(BBDD_Natural_Gas$Date)
Month <- month(BBDD_Natural_Gas$Date)
Quarter <- quarter(BBDD_Natural_Gas$Date)
Profit_NatGas <- c(BBDD_Natural_Gas$`NG=F.Adjusted`-BBDD_Natural_Gas$`NG=F.Open`)
Variabilitat_NatGas <- c(BBDD_Natural_Gas$`NG=F.High` -BBDD_Natural_Gas$`NG=F.Low`)

NatGas_prices <- BBDD_Natural_Gas[, "NG=F.Adjusted", drop = FALSE];n <- nrow(NatGas_prices)
Return_NatGas <- ((NatGas_prices[2:n, 1] - NatGas_prices[1:(n-1), 1])/NatGas_prices[1:(n-1), 1])
Return_NatGas <- as.data.frame(Return_NatGas);Return_NatGas <- rbind(0, Return_NatGas)

BBDD_Natural_Gas <- as.matrix(BBDD_Natural_Gas);BBDD_Natural_Gas <- cbind(BBDD_Natural_Gas,Semester,Quarter,Month, Profit_NatGas, Variabilitat_NatGas, Return_NatGas);BBDD_Natural_Gas <- as.data.frame(BBDD_Natural_Gas)
BBDD_Natural_Gas$Date <- as.Date(BBDD_Natural_Gas$Date)

BBDD_Natural_Gas$Profit_NatGas <- as.numeric(BBDD_Natural_Gas$Profit_NatGas)
BBDD_Natural_Gas$`NG=F.Open` <- as.numeric(BBDD_Natural_Gas$`NG=F.Open`)
BBDD_Natural_Gas$`NG=F.High` <- as.numeric(BBDD_Natural_Gas$`NG=F.High`)
BBDD_Natural_Gas$`NG=F.Low` <- as.numeric(BBDD_Natural_Gas$`NG=F.Low`)
BBDD_Natural_Gas$`NG=F.Close` <- as.numeric(BBDD_Natural_Gas$`NG=F.Close`)
BBDD_Natural_Gas$`NG=F.Volume` <- as.numeric(BBDD_Natural_Gas$`NG=F.Volume`)
BBDD_Natural_Gas$`NG=F.Adjusted` <- as.numeric(BBDD_Natural_Gas$`NG=F.Adjusted`)
BBDD_Natural_Gas$Variabilitat_NatGas <- as.numeric(BBDD_Natural_Gas$Variabilitat_NatGas)

Natural_Gas_Time_Series <- ts(BBDD_Natural_Gas$`NG=F.Adjusted`, start = 2000, frequency = 365)
```

```{r Datos GOLD, warning=FALSE, echo=FALSE}

###########################################################################
#Gold
###########################################################################

BBDD_Gold<- getSymbols('GC=F', from=mdate, auto.assign = F)
BBDD_Gold <- na.omit(BBDD_Gold)
chartSeries(BBDD_Gold, name = "Gold Price Evolution")
Returns_Gold <- CalculateReturns(BBDD_Gold$`GC=F.Adjusted`);Returns_Gold <- Returns_Gold[-c(1),]

BBDD_Gold <- as.matrix(BBDD_Gold)
Date <- rownames(BBDD_Gold)
BBDD_Gold<-as.data.frame(BBDD_Gold)
BBDD_Gold$Date<-Date
rownames(BBDD_Gold)<- NULL
BBDD_Gold$Date <- as.Date(BBDD_Gold$Date)

Semester <- semester(BBDD_Gold$Date)
Month <- month(BBDD_Gold$Date)
Quarter <- quarter(BBDD_Gold$Date)
Profit_Gold <- c(BBDD_Gold$`GC=F.Adjusted`-BBDD_Gold$`GC=F.Open`)
Variabilitat_Gold <- c(BBDD_Gold$`GC=F.High` -BBDD_Gold$`GC=F.Low`)

Gold_prices <- BBDD_Gold[, "GC=F.Adjusted", drop = FALSE];n <- nrow(Gold_prices)
Return_Gold <- ((Gold_prices[2:n, 1] - Gold_prices[1:(n-1), 1])/Gold_prices[1:(n-1), 1])
Return_Gold <- as.data.frame(Return_Gold);Return_Gold <- rbind(0, Return_Gold)

BBDD_Gold <- as.matrix(BBDD_Gold);BBDD_Gold <- cbind(BBDD_Gold,Semester,Quarter,Month, Profit_Gold, Variabilitat_Gold, Return_Gold);BBDD_Gold <- as.data.frame(BBDD_Gold)
BBDD_Gold$Date <- as.Date(BBDD_Gold$Date)

BBDD_Gold$Profit_Gold <- as.numeric(BBDD_Gold$Profit_Gold)
BBDD_Gold$`GC=F.Open` <- as.numeric(BBDD_Gold$`GC=F.Open`)
BBDD_Gold$`GC=F.High` <- as.numeric(BBDD_Gold$`GC=F.High`)
BBDD_Gold$`GC=F.Low` <- as.numeric(BBDD_Gold$`GC=F.Low`)
BBDD_Gold$`GC=F.Close` <- as.numeric(BBDD_Gold$`GC=F.Close`)
BBDD_Gold$`GC=F.Volume` <- as.numeric(BBDD_Gold$`GC=F.Volume`)
BBDD_Gold$`GC=F.Adjusted` <- as.numeric(BBDD_Gold$`GC=F.Adjusted`)
BBDD_Gold$Variabilitat_Gold <- as.numeric(BBDD_Gold$Variabilitat_Gold)

Gold_Time_Series <- ts(BBDD_Gold$`GC=F.Adjusted`, start = 2000, frequency = 365)
```

```{r Datos COPPER, warning=FALSE, echo=FALSE}

###########################################################################
#Copper
###########################################################################

BBDD_Copper<- getSymbols('HG=F', from=mdate, auto.assign = F)
BBDD_Copper <- na.omit(BBDD_Copper)
chartSeries(BBDD_Copper, name = "Copper Price Evolution")
Returns_Copper <- CalculateReturns(BBDD_Copper$`HG=F.Adjusted`);Returns_Copper <- Returns_Copper[-c(1),]

BBDD_Copper <- as.matrix(BBDD_Copper)
Date <- rownames(BBDD_Copper)
BBDD_Copper<-as.data.frame(BBDD_Copper)
BBDD_Copper$Date<-Date
rownames(BBDD_Copper)<- NULL
BBDD_Copper$Date <- as.Date(BBDD_Copper$Date)

Semester <- semester(BBDD_Copper$Date)
Month <- month(BBDD_Copper$Date)
Quarter <- quarter(BBDD_Copper$Date)
Profit_Copper <- c(BBDD_Copper$`HG=F.Adjusted`-BBDD_Copper$`HG=F.Open`)
Variabilitat_Copper <- c(BBDD_Copper$`HG=F.High` -BBDD_Copper$`HG=F.Low`)

Copper_prices <- BBDD_Copper[, "HG=F.Adjusted", drop = FALSE];n <- nrow(Copper_prices)
Return_Copper <- ((Copper_prices[2:n, 1] - Copper_prices[1:(n-1), 1])/Copper_prices[1:(n-1), 1])
Return_Copper <- as.data.frame(Return_Copper);Return_Copper <- rbind(0, Return_Copper)

BBDD_Copper <- as.matrix(BBDD_Copper);BBDD_Copper <- cbind(BBDD_Copper,Semester,Quarter,Month, Profit_Copper, Variabilitat_Copper, Return_Copper);BBDD_Copper <- as.data.frame(BBDD_Copper)
BBDD_Copper$Date <- as.Date(BBDD_Copper$Date)

BBDD_Copper$Profit_Copper <- as.numeric(BBDD_Copper$Profit_Copper)
BBDD_Copper$`HG=F.Open` <- as.numeric(BBDD_Copper$`HG=F.Open`)
BBDD_Copper$`HG=F.High` <- as.numeric(BBDD_Copper$`HG=F.High`)
BBDD_Copper$`HG=F.Low` <- as.numeric(BBDD_Copper$`HG=F.Low`)
BBDD_Copper$`HG=F.Close` <- as.numeric(BBDD_Copper$`HG=F.Close`)
BBDD_Copper$`HG=F.Volume` <- as.numeric(BBDD_Copper$`HG=F.Volume`)
BBDD_Copper$`HG=F.Adjusted` <- as.numeric(BBDD_Copper$`HG=F.Adjusted`)
BBDD_Copper$Variabilitat_Copper <- as.numeric(BBDD_Copper$Variabilitat_Copper)

Copper_Time_Series <- ts(BBDD_Copper$`HG=F.Adjusted`, start = 2000, frequency = 365)
```

```{r Datos EURUSD, warning=FALSE, echo=FALSE}

###########################################################################
#EUR/USD
###########################################################################

mdate="2000-01-01"
BBDD_EURUSD <-getSymbols('EURUSD=X', from=mdate, auto.assign = F)
BBDD_EURUSD <- na.omit(BBDD_EURUSD)
BBDD_EURUSD <- BBDD_EURUSD[-1116,]
BBDD_EURUSD <- BBDD_EURUSD[-2105,]
chartSeries(BBDD_EURUSD, name = "EUR/USD Price Evolution")
Returns_EURUSD <- CalculateReturns(BBDD_EURUSD$`EURUSD=X.Adjusted`);Returns_EURUSD <- Returns_EURUSD[-c(1),]

BBDD_EURUSD <- as.matrix(BBDD_EURUSD)
Date <- rownames(BBDD_EURUSD)
BBDD_EURUSD<-as.data.frame(BBDD_EURUSD)
BBDD_EURUSD$Date<-Date
rownames(BBDD_EURUSD)<- NULL
BBDD_EURUSD$Date <- as.Date(BBDD_EURUSD$Date)
Semester <- semester(BBDD_EURUSD$Date)
Month <- month(BBDD_EURUSD$Date)
Quarter <- quarter(BBDD_EURUSD$Date)
Profit_EURUSD <- c(BBDD_EURUSD$`EURUSD=X.Adjusted`-BBDD_EURUSD$`EURUSD=X.Open`)
Variabilitat_EURUSD <- c(BBDD_EURUSD$`EURUSD=X.High`-BBDD_EURUSD$`EURUSD=X.Low`)

EURUSD_prices <- BBDD_EURUSD[, "EURUSD=X.Adjusted", drop = FALSE];n <- nrow(EURUSD_prices)
Return_EURUSD <- ((EURUSD_prices[2:n, 1] - EURUSD_prices[1:(n-1), 1])/EURUSD_prices[1:(n-1), 1])
Return_EURUSD <- as.data.frame(Return_EURUSD);Return_EURUSD <- rbind(0, Return_EURUSD)

BBDD_EURUSD <- as.matrix(BBDD_EURUSD);BBDD_EURUSD <- cbind(BBDD_EURUSD,Semester,Quarter,Month, Profit_EURUSD, Variabilitat_EURUSD, Return_EURUSD);BBDD_EURUSD <- as.data.frame(BBDD_EURUSD)
BBDD_EURUSD$Date <- as.Date(BBDD_EURUSD$Date)

BBDD_EURUSD$Profit_EURUSD <- as.numeric(BBDD_EURUSD$Profit_EURUSD)
BBDD_EURUSD$`EURUSD=X.Open` <- as.numeric(BBDD_EURUSD$`EURUSD=X.Open`)
BBDD_EURUSD$`EURUSD=X.High` <- as.numeric(BBDD_EURUSD$`EURUSD=X.High`)
BBDD_EURUSD$`EURUSD=X.Low` <- as.numeric(BBDD_EURUSD$`EURUSD=X.Low`)
BBDD_EURUSD$`EURUSD=X.Close` <- as.numeric(BBDD_EURUSD$`EURUSD=X.Close`)
BBDD_EURUSD$`EURUSD=X.Volume` <- as.numeric(BBDD_EURUSD$`EURUSD=X.Volume`)
BBDD_EURUSD$`EURUSD=X.Adjusted` <- as.numeric(BBDD_EURUSD$`EURUSD=X.Adjusted`)
BBDD_EURUSD$Variabilitat_EURUSD <- as.numeric(BBDD_EURUSD$Variabilitat_EURUSD)

EURUSD_Time_Series <- ts(BBDD_EURUSD$`EURUSD=X.Adjusted`, start = 2000, frequency = 365)
```

```{r Datos TY10, warning=FALSE, echo=FALSE}

###########################################################################
#US Treasury Yield 10 Years
###########################################################################

mdate="2000-01-01"
BBDD_TY10 <-getSymbols('^TNX', from=mdate, auto.assign = F)
BBDD_TY10 <- na.omit(BBDD_TY10)
chartSeries(BBDD_TY10, name = "TY10 Price Evolution")
Returns_TY10 <- CalculateReturns(BBDD_TY10$TNX.Adjusted);Returns_TY10 <- Returns_TY10[-c(1),]

BBDD_TY10 <- as.matrix(BBDD_TY10)
Date <- rownames(BBDD_TY10)
BBDD_TY10<-as.data.frame(BBDD_TY10)
BBDD_TY10$Date<-Date
rownames(BBDD_TY10)<- NULL
BBDD_TY10$Date <- as.Date(BBDD_TY10$Date)
Semester <- semester(BBDD_TY10$Date)
Month <- month(BBDD_TY10$Date)
Quarter <- quarter(BBDD_TY10$Date)
Profit_TY10 <- c(BBDD_TY10$TNX.Adjusted-BBDD_TY10$TNX.Open)
Variabilitat_TY10 <- c(BBDD_TY10$TNX.High-BBDD_TY10$TNX.Low)

TY10_prices <- BBDD_TY10[, "TNX.Adjusted", drop = FALSE];n <- nrow(TY10_prices)
Return_TY10 <- ((TY10_prices[2:n, 1] - TY10_prices[1:(n-1), 1])/TY10_prices[1:(n-1), 1])
Return_TY10 <- as.data.frame(Return_TY10);Return_TY10 <- rbind(0, Return_TY10)

BBDD_TY10 <- as.matrix(BBDD_TY10);BBDD_TY10 <- cbind(BBDD_TY10,Semester,Quarter,Month, Profit_TY10, Variabilitat_TY10, Return_TY10);BBDD_TY10 <- as.data.frame(BBDD_TY10)
BBDD_TY10$Date <- as.Date(BBDD_TY10$Date)

BBDD_TY10$Profit_TY10 <- as.numeric(BBDD_TY10$Profit_TY10)
BBDD_TY10$TNX.Open <- as.numeric(BBDD_TY10$TNX.Open)
BBDD_TY10$TNX.High <- as.numeric(BBDD_TY10$TNX.High)
BBDD_TY10$TNX.Low <- as.numeric(BBDD_TY10$TNX.Low)
BBDD_TY10$TNX.Close <- as.numeric(BBDD_TY10$TNX.Close)
BBDD_TY10$TNX.Volume <- as.numeric(BBDD_TY10$TNX.Volume)
BBDD_TY10$TNX.Adjusted <- as.numeric(BBDD_TY10$TNX.Adjusted)
BBDD_TY10$Variabilitat_TY10 <- as.numeric(BBDD_TY10$Variabilitat_TY10)

TY10_Time_Series <- ts(BBDD_TY10$TNX.Adjusted, start = 2000, frequency = 365)
```

###########################################################################
ANÁLISIS DE LAS SERIES TEMPORALES
###########################################################################

```{r, warning=FALSE}
time_series_analysis <- function(TS){
  ts_decompose(TS)
  checkresiduals(remainder(decompose(TS)))
  ts_seasonal(TS)
  ts_cor(TS, lag.max = 364)
  ts_lags(TS)
}

time_series_analysis(SP500_Time_Series)
time_series_analysis(DAX_Time_Series)
time_series_analysis(HongKongSE_Time_Series)
time_series_analysis(Crude_Oil_Time_Series)
time_series_analysis(Natural_Gas_Time_Series)
time_series_analysis(Gold_Time_Series)
time_series_analysis(Copper_Time_Series)
time_series_analysis(EURUSD_Time_Series)
time_series_analysis(TY10_Time_Series)
```

```{r}
Analisis_Time_Series2 <- function(BBDD,BBDD_TS, Adjusted, ticker, Title) {
  
  Decomp <- ts_decompose(BBDD_TS); print(Decomp)
  checkresiduals(remainder(decompose(BBDD_TS)))
  Seasonal <- ts_seasonal(BBDD_TS); print(Seasonal)
  Stationarity <- ts_cor(BBDD_TS, lag.max = 364); print(Stationarity)

}

Analisis_Time_Series2(BBDD_SP500, SP500_Time_Series)
Analisis_Time_Series2(BBDD_DAX, DAX_Time_Series)
Analisis_Time_Series2(BBDD_HongKongSE, HongKongSE_Time_Series)
Analisis_Time_Series2(BBDD_Crude_Oil, Crude_Oil_Time_Series)
Analisis_Time_Series2(BBDD_Natural_Gas, Natural_Gas_Time_Series)
Analisis_Time_Series2(BBDD_Gold, Gold_Time_Series)
Analisis_Time_Series2(BBDD_Copper, Copper_Time_Series)
Analisis_Time_Series2(BBDD_EURUSD, EURUSD_Time_Series)
Analisis_Time_Series2(BBDD_TY10, TY10_Time_Series)

```

```{r Funcion_Volatilidad, warning=FALSE}
Funcion_Volatilidad <- function(ticker, Title){
   New_BBDD <-getSymbols(ticker, from=mdate, auto.assign = F);New_BBDD <- na.omit(New_BBDD)
  Returns_Asset <- CalculateReturns(New_BBDD[,6]); Returns_Asset <-Returns_Asset[-c(1),]
  Volatility <- (chart.RollingPerformance(R=Returns_Asset["2000::2022"], width = 22, FUN = "sd.annualized",      scale = 252,      main   =Title))
  return(Volatility)  
}
Funcion_Volatilidad('^GSPC', "Standard&Poor's Stock Exchange Monthly Volatility")
Funcion_Volatilidad('^GDAXI', "Dax Stock Exchange Monthly Volatility")
Funcion_Volatilidad('^HSI', "HongKong Stock Exchange Monthly Volatility")
Funcion_Volatilidad('CL=F', "Oil's Futures Monthly Volatility")
Funcion_Volatilidad('NG=F', "Natural Gas Futures Monthly Volatility")
Funcion_Volatilidad('GC=F', "Gold's Futures Monthly Volatility")
Funcion_Volatilidad('HG=F', "Copper's Futures Monthly Volatility")
Funcion_Volatilidad('EURUSD=X', "Euro/Dolar Monthly Volatility")
Funcion_Volatilidad('^TNX', "10 Years US Treasury Bonds Monthly Volatility")
```

###########################################################################
ANÁLISIS DE LOS RETURNS DE LOS ACTIVOS
###########################################################################

```{r Comparación de Returns de todos los Activos, warning=FALSE, echo=FALSE}
Indicador_Asset <- c("^GSPC", "^GDAXI", "^HSI", "CL=F", "NG=F", "GC=F", "HG=F", "EURUSD=X", "^TNX" ) 
Multple_Assets <- tq_get(Indicador_Asset,
                        from = "2000-01-01",
                        to = "2023-03-17",
                        get = "stock.prices")
multpl_stock_monthly_returns <- Multple_Assets %>%
  group_by(symbol) %>%                             
  tq_transmute(select = adjusted,
               mutate_fun = periodReturn,
               period = 'monthly',
               col_rename = 'returns')

multpl_stock_monthly_returns %>%
  mutate(returns = if_else(date == "2013-01-31", 0, returns)) %>%
  group_by(symbol) %>% 
  mutate(cr = cumprod(1 + returns)) %>%
  mutate(cumulative_returns = cr - 1) %>%
  ggplot(aes(x = date, y = cumulative_returns, color = symbol)) +
  geom_line() +
  labs(x = "Date", y = "Cumulative Returns") +
  ggtitle("Cumulative returns for all financial assets since year 2000") +
  scale_y_continuous(breaks = seq(0,20,2),
                     labels = scales::percent) +
  scale_color_brewer(palette = "Set1",
                     name = "") +
  theme_bw()
```

```{r}
Asset_Return_Analysis <- function(Ret){
  chart.Histogram(Ret,   method = c("add.density","add.normal") , colorset = c("blue","red","black"))
  legend("topright", legend = c("return","kernel","normal dist."), fill = c("blue","red","black"))
  acf(Ret)
  pacf(Ret)
}

Asset_Return_Analysis(Returns_SP)
BBDD_SP500 %>% plot_time_series(Date, Return_SP, .facet_scales = "free", .interactive = FALSE)
BBDD_SP500 %>% plot_seasonal_diagnostics(Date, Return_SP, .interactive = FALSE)

Asset_Return_Analysis(Returns_Dax)
BBDD_DAX %>% plot_time_series(Date, Return_Dax, .facet_scales = "free", .interactive = FALSE)
BBDD_DAX %>% plot_seasonal_diagnostics(Date, Return_Dax, .interactive = FALSE)

Asset_Return_Analysis(Returns_Oil)
BBDD_Crude_Oil %>% plot_time_series(Date, Return_Oil, .facet_scales = "free", .interactive = FALSE)
BBDD_Crude_Oil %>% plot_seasonal_diagnostics(Date, Return_Oil, .interactive = FALSE)

Asset_Return_Analysis(Returns_NG)
BBDD_Natural_Gas %>% plot_time_series(Date, Return_NatGas, .facet_scales = "free", .interactive = FALSE)
BBDD_Natural_Gas %>% plot_seasonal_diagnostics(Date, Return_NatGas, .interactive = FALSE)

Asset_Return_Analysis(Returns_Gold)
BBDD_Gold %>% plot_time_series(Date, Return_Gold, .facet_scales = "free", .interactive = FALSE)
BBDD_Gold %>% plot_seasonal_diagnostics(Date, Return_Gold, .interactive = FALSE)

Asset_Return_Analysis(Returns_Copper)
BBDD_Copper %>% plot_time_series(Date, Return_Copper, .facet_scales = "free", .interactive = FALSE)
BBDD_Copper %>% plot_seasonal_diagnostics(Date, Return_Copper, .interactive = FALSE)

Asset_Return_Analysis(Returns_EURUSD)
BBDD_EURUSD %>% plot_time_series(Date, Return_EURUSD, .facet_scales = "free", .interactive = FALSE)
BBDD_EURUSD %>% plot_seasonal_diagnostics(Date, Return_EURUSD, .interactive = FALSE)

Asset_Return_Analysis(Returns_TY10)
BBDD_TY10 %>% plot_time_series(Date, Return_TY10, .facet_scales = "free", .interactive = FALSE)
BBDD_TY10 %>% plot_seasonal_diagnostics(Date, Return_TY10, .interactive = FALSE)

```


```{r Diferenciación Series, warning=FALSE, echo=FALSE}

SP500_diferenciado <- diff(log(SP500_Time_Series)); ts_decompose(SP500_diferenciado)
Dax_diferenciado <- diff(log(DAX_Time_Series)); ts_decompose(Dax_diferenciado)
HK_diferenciado <- diff(log(HongKongSE_Time_Series)); ts_decompose(HK_diferenciado)
Oil_diferenciado <- diff(Crude_Oil_Time_Series); ts_decompose(Oil_diferenciado)
Natgas_diferenciado <- diff(log(Natural_Gas_Time_Series)); ts_decompose(Natgas_diferenciado)
Gold_diferenciado <- diff(log(Gold_Time_Series)); ts_decompose(Gold_diferenciado)
Copper_diferenciado <- diff(log(Copper_Time_Series)); ts_decompose(Copper_diferenciado)
EURUSD_diferenciado <- diff(log(EURUSD_Time_Series)); ts_decompose(EURUSD_diferenciado)
TY10_diferenciado <- diff(log(TY10_Time_Series)); ts_decompose(TY10_diferenciado)
```


```{r Análisis ARIMA SP Diferenciado, warning=FALSE, echo=FALSE}

Analisis_Diff_NoDiff <- function(Asset_TS, Asset_TS_Diff){
  print(ts_cor(Asset_TS))
  print(adf.test(Asset_TS))
  print(kpss.test(Asset_TS))
  ts_decompose(Asset_TS)

  print(ts_cor(Asset_TS_Diff))
  print(adf.test(Asset_TS_Diff))
  print(kpss.test(Asset_TS_Diff))
  ts_decompose(Asset_TS_Diff)

}

Analisis_Diff_NoDiff(SP500_Time_Series, SP500_diferenciado)
Analisis_Diff_NoDiff(DAX_Time_Series, Dax_diferenciado)
Analisis_Diff_NoDiff(HongKongSE_Time_Series, HK_diferenciado)
Analisis_Diff_NoDiff(Crude_Oil_Time_Series, Oil_diferenciado)
Analisis_Diff_NoDiff(Natural_Gas_Time_Series, Natgas_diferenciado)
Analisis_Diff_NoDiff(Gold_Time_Series, Gold_diferenciado)
Analisis_Diff_NoDiff(Copper_Time_Series, Copper_diferenciado)
Analisis_Diff_NoDiff(EURUSD_Time_Series, EURUSD_diferenciado)
Analisis_Diff_NoDiff(TY10_Time_Series, TY10_diferenciado)
```




```{r}
Auto_Arima_Train <- function(Asset_TS, Asset_Data){
  Data_Time_Series <- xts(Asset_TS, order.by=as.POSIXct(Asset_Data$Date));Data_Time_Series <- ts(Data_Time_Series, frequency = 252)
  Section_Data <- round(length(Data_Time_Series)*0.3)
  Training_Data <- subset(Data_Time_Series, end=length(Data_Time_Series)-Section_Data)
  Test_Data <- subset(Data_Time_Series, start=length(Data_Time_Series)-Section_Data-1)
  auto.arima(Training_Data, trace = T, seasonal = F) 
  auto.arima(Training_Data, trace = T, seasonal = T) 
}

Auto_Arima_Train(SP500_Time_Series,BBDD_SP500)
Auto_Arima_Train(SP500_diferenciado, BBDD_SP500)

Auto_Arima_Train(DAX_Time_Series, BBDD_DAX)
Auto_Arima_Train(Dax_diferenciado, BBDD_DAX)

Auto_Arima_Train(HongKongSE_Time_Series, BBDD_HongKongSE)
Auto_Arima_Train(HK_diferenciado, BBDD_HongKongSE)

Auto_Arima_Train(Crude_Oil_Time_Series, BBDD_Crude_Oil)
Auto_Arima_Train(Oil_diferenciado, BBDD_Crude_Oil)

Auto_Arima_Train(Natural_Gas_Time_Series, BBDD_Natural_Gas)
Auto_Arima_Train(Natgas_diferenciado, BBDD_Natural_Gas)

Auto_Arima_Train(Gold_Time_Series, BBDD_Gold)
Auto_Arima_Train(Gold_diferenciado, BBDD_Gold)

Auto_Arima_Train(Copper_Time_Series, BBDD_Copper)
Auto_Arima_Train(Copper_diferenciado, BBDD_Copper)

Auto_Arima_Train(EURUSD_Time_Series, BBDD_EURUSD)
Auto_Arima_Train(EURUSD_diferenciado, BBDD_EURUSD)

Auto_Arima_Train(TY10_Time_Series, BBDD_TY10)
Auto_Arima_Train(TY10_diferenciado, BBDD_TY10)
```

```{r Funcion_Bondad_Modelos_Predicciones_Historicas_Visual}

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual <- function(data, data_ts, data_ts_diff, order_data_arima, order_data_arima_diff, order_data_sarima, order_data_sarima_diff, seasonal_data, seasonal_data_diff, ggtitle_Arima,ggtitle_Arima_Diff,  ggtitle_Sarima, ggtitle_Sarima_Diff, seasonal_arima){
  
  Data_Time_Series <- xts(data_ts, order.by=as.POSIXct(data$Date))
  Data_Time_Series <- ts(Data_Time_Series)
  Section_Data <- round(length(Data_Time_Series)*0.3)
  Training_Data <- subset(Data_Time_Series, end=length(Data_Time_Series)-Section_Data)
  Test_Data <- subset(Data_Time_Series, start=length(Data_Time_Series)-Section_Data-1)

  Data_Time_Series_Diff <- xts(data_ts_diff, order.by=as.POSIXct(data[-1,]$Date));Data_Time_Series_Diff <- ts(Data_Time_Series_Diff)
  Section_Data_Diff <- round(length(Data_Time_Series_Diff)*0.3)
  Training_Data_Diff <- subset(Data_Time_Series_Diff, end=length(Data_Time_Series_Diff)-Section_Data_Diff)
  Test_Data_Diff <- subset(Data_Time_Series_Diff, start=length(Data_Time_Series_Diff)-Section_Data_Diff-1)
  
  ################ ARIMA ################
  Arima_Train_Data <- Arima(Training_Data, order=order_data_arima, seasonal = seasonal_arima,include.drift=TRUE)#
  Arima_PLOT <- Arima_Train_Data %>%
    forecast(h=length(Test_Data)) %>%
    autoplot() + autolayer(Test_Data) + ggtitle(ggtitle_Arima)

  Arima_Train_Data_Diff <- Arima(Training_Data_Diff, order=order_data_arima_diff, seasonal = seasonal_arima)
  Arima_Diff_PLOT <- Arima_Train_Data_Diff %>%
    forecast(h=length(Test_Data_Diff)) %>%
    autoplot() + autolayer(Test_Data_Diff) + ggtitle(ggtitle_Arima_Diff)

  ################ SARIMA ################

  Sarima_Train_Data <- Arima(Training_Data, order=order_data_sarima, seasonal=seasonal_data,include.drift=TRUE)
  Sarima_PLOT <- Sarima_Train_Data %>%
    forecast(h=length(Test_Data)) %>%
    autoplot() + autolayer(Test_Data) + ggtitle(ggtitle_Sarima)

  Sarima_Train_Data_Diff <- Arima(Training_Data_Diff, order=order_data_sarima_diff, seasonal=seasonal_data_diff, include.drift=TRUE)
  Sarima_Diff_PLOT <- Sarima_Train_Data_Diff %>%
    forecast(h=length(Test_Data_Diff)) %>%
    autoplot() + autolayer(Test_Data_Diff) + ggtitle(ggtitle_Sarima_Diff)
  
  ############## HOLT ES #################
  
  Holt_ES_Data <- holt(Training_Data,h = length(Test_Data));
  Holt_ES_PLOT <- autoplot(Holt_ES_Data) + autolayer(Test_Data)
  
  Holt_ES_Data_Diff <- holt(Training_Data_Diff,h = length(Test_Data_Diff))
  Holt_ES_Diff_PLOT <- autoplot(Holt_ES_Data_Diff) + autolayer(Test_Data_Diff)
  
  ################ TBATS ################
  
  TBATS_Data <- tbats(Training_Data, use.trend = TRUE, use.box.cox =TRUE, use.damped.trend=TRUE);Predict_Data <- predict(TBATS_Data)
  TBATS_PLOT <- forecast(TBATS_Data, h=length(Test_Data)) %>%
    autoplot() + autolayer(Test_Data)
  
  TBATS_Data_Diff <- tbats(Training_Data_Diff);Predict_Data_Diff <- predict(TBATS_Data_Diff)
  TBATS_DIFF_PLOT <- TBATS_Data_Diff %>%
    forecast(h=length(Test_Data_Diff)) %>%
    autoplot() + autolayer(Test_Data_Diff) 
  
#(Arima_PLOT+Arima_Diff_PLOT+Sarima_PLOT+Sarima_Diff_PLOT)/(Holt_ES_PLOT+Holt_ES_Diff_PLOT+TBATS_PLOT+TBATS_DIFF_PLOT)  

plot(Arima_PLOT)
plot(Sarima_PLOT)
plot(Holt_ES_PLOT)
plot(TBATS_PLOT)

}
```

```{r, warning=FALSE}
Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_SP500, SP500_Time_Series, SP500_diferenciado, c(1,1,2), c(1,1,2), c(4,1,3), c(4,1,3), c(0,1,0), c(0,1,0), "Forecastsing S&P500 from ARIMA(1,1,2)", "Forecastsing S&P500 from ARIMA(1,0,2) with zero mean", "Forecastsing S&P500 from SARIMA(1,1,2)", "Forecastsing S&P500 from SARIMA(1,0,2) with zero mean", c(0,0,0))

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_DAX, DAX_Time_Series, Dax_diferenciado, c(0,1,0), c(0,1,0), c(0,1,0,252), c(0,1,0,252), c(0,1,0,252), c(0,1,0,252), "Forecasting DAX from ARIMA(0,1,0)", "Forecasting DAX from ARIMA(3,0,2) with zero mean", "Forecasting DAX from SARIMA(0,1,0) ", "Forecasting DAX from SARIMA(3,0,2) with zero mean", c(0,0,0,0))

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_HongKongSE, HongKongSE_Time_Series, HK_diferenciado, c(2,1,3), c(2,1,3), c(3,1,0), c(3,1,0), c(0,1,0), c(0,1,0), "Forecasting Kong Kong Stock Exchange from ARIMA(2,1,3)", "Forecasting Kong Kong Stock Exchang from ARIMA(3,0,2) with non-zero mean", "Forecasting Kong Kong Stock Exchange from SARIMA(2,1,3) ", "Forecasting Kong Kong Stock Exchange from SARIMA(3,0,2) with non-zero mean", c(0,0,0)) 

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_Crude_Oil,Crude_Oil_Time_Series, Oil_diferenciado, c(2,1,3), c(2,1,3), c(0,1,1), c(0,1,1), c(0,1,0), c(0,1,0), "Forecasting Crude Oil's Futures from ARIMA(2,1,3)", "Forecasting Crude Oil's Futures from ARIMA(2,0,3) with zero mean", "Forecasting Crude Oil's Futures from SARIMA(2,1,3) ", "Forecasting Crude Oil's Futures from SARIMA(2,0,3) with zero mean", c(0,0,0))

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_Natural_Gas, Natural_Gas_Time_Series, Natgas_diferenciado, c(0,1,0), c(0,1,0), c(1,1,1), c(1,1,1), c(0,1,0), c(0,1,0), "Forecasting Natural Gas Futures from ARIMA(0,1,0)", "Forecasting Natural Gas Futures from ARIMA(1,0,1) with zero mean", "Forecasting Natural Gas Futures from SARIMA(0,1,0) ", "Forecasting Natural Gas Futures from SARIMA(1,0,1) with zero mean", c(0,0,0))

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_Gold ,Gold_Time_Series, Gold_diferenciado, c(0,1,0), c(0,1,0), c(0,1,0), c(0,1,0), c(0,1,0), c(0,1,0), "Forecasting Gold's Futures from ARIMA(0,1,0)", "Forecasting Gold's Futures from ARIMA(0,0,0) with non-zero mean", "Forecasting Gold's Futures from SARIMA(0,1,0) ", "Forecasting Gold's Futures from SARIMA(0,0,0) with non-zero mean", c(0,0,0))

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_Copper, Copper_Time_Series, Copper_diferenciado,  c(0,1,1), c(0,1,1), c(1,1,0), c(1,1,0), c(0,1,0), c(0,1,0), "Forecasting Copper's Futures from ARIMA(0,1,1)", "Forecasting Copper's Futures from ARIMA(0,0,0) with non-zero mean", "Forecasting Copper's Futures from SARIMA(0,1,1) ", "Forecasting Copper's Futures from SARIMA(0,0,0) with non-zero mean", c(0,0,0))

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_EURUSD,EURUSD_Time_Series, EURUSD_diferenciado, c(1,1,1), c(1,1,1), c(2,1,0), c(2,1,0), c(0,1,0), c(0,1,0), "Forecasting EUR/USD from ARIMA(1,1,1)", "Forecasting EUR/USD from ARIMA(1,0,1) with zero mean", "Forecasting EUR/USD from SARIMA(1,1,1) ", "Forecasting EUR/USD from SARIMA(1,0,1) with zero mean", c(0,0,0))

Funcion_Bondad_Modelos_Predicciones_Historicas_Visual(BBDD_TY10,TY10_Time_Series, TY10_diferenciado, c(2,1,2), c(2,1,2), c(2,1,0), c(2,1,0), c(0,1,0), c(0,1,0), "Forecasting US Treasury Bonds from ARIMA(2,1,2)", "Forecasting US Treasury Bonds from ARIMA(0,0,0) with zero mean", "Forecasting US Treasury Bonds from SARIMA(2,1,2) ", "Forecasting US Treasury Bonds from SARIMA(0,0,0) with zero mean", c(0,0,0))
```

```{r Funcion_Accuracy_Predicciones_Historicas}

Funcion_Accuracy_Predicciones_Historicas <- function(data, data_ts, data_ts_diff, order_data_arima, order_data_arima_diff, order_data_sarima, order_data_sarima_diff, seasonal_data, seasonal_data_diff, ggtitle_Sarima, ggtitle_Sarima_Diff, seasonal_data_arima ){
  Data_Time_Series <- xts(data_ts, order.by=as.POSIXct(data$Date))
  Data_Time_Series <- ts(Data_Time_Series)
  Section_Data <- round(length(Data_Time_Series)*0.3)
  Training_Data <- subset(Data_Time_Series, end=length(Data_Time_Series)-Section_Data)
  Test_Data <- subset(Data_Time_Series, start=length(Data_Time_Series)-Section_Data-1)

  Data_Time_Series_Diff <- xts(data_ts_diff, order.by=as.POSIXct(data[-1,]$Date));Data_Time_Series_Diff <- ts(Data_Time_Series_Diff)
  Section_Data_Diff <- round(length(Data_Time_Series_Diff)*0.3)
  Training_Data_Diff <- subset(Data_Time_Series_Diff, end=length(Data_Time_Series_Diff)-Section_Data_Diff)
  Test_Data_Diff <- subset(Data_Time_Series_Diff, start=length(Data_Time_Series_Diff)-Section_Data_Diff-1)
  
  ################ DATA ##################
  
  Arima_Train_Data <- Arima(Training_Data, order=order_data_arima, seasonal=seasonal_data_arima, lambda = 0)
  Arima_Train_Data_Diff <- Arima(Training_Data_Diff, order=order_data_arima_diff, seasonal=seasonal_data_arima)
  Sarima_Train_Data <- Arima(Training_Data, order=order_data_sarima, seasonal=seasonal_data)#, lambda = lambda_sarima
  Sarima_Train_Data_Diff <- Arima(Training_Data_Diff, order=order_data_sarima_diff, seasonal=seasonal_data_diff)
  Holt_ES_Data <- holt(Training_Data,h = length(Test_Data))
  Holt_ES_Data_Diff <- holt(Training_Data_Diff,h = length(Test_Data_Diff))
  TBATS_Data <- tbats(Training_Data)
  TBATS_Data_Diff <- tbats(Training_Data_Diff)
  
  ############### ACCURACY ###############
  
  print(accuracy(Arima_Train_Data %>% forecast(h=length(Test_Data)) , Test_Data))
  print(accuracy(Sarima_Train_Data %>% forecast(h=length(Test_Data)) , Test_Data))
  print(accuracy(Holt_ES_Data, Test_Data))
  print(accuracy(TBATS_Data %>% forecast(h=length(Test_Data)) , Test_Data))
  
  print(accuracy(Arima_Train_Data_Diff %>% forecast(h=length(Test_Data_Diff)), Test_Data_Diff))
  print(accuracy(Sarima_Train_Data_Diff %>% forecast(h=length(Test_Data_Diff)), Test_Data_Diff))
  print(accuracy(Holt_ES_Data_Diff, Test_Data_Diff))
  print(accuracy(TBATS_Data_Diff %>% forecast(h=length(Test_Data_Diff)) , Test_Data_Diff))
  
  
  #print(accuracy(Arima_Train_Data %>% forecast(h=length(Test_Data)) , Test_Data))
  #print(summary(Arima_Train_Data))
  #Plot_Resid_Arima <- plot(resid(Arima_Train_Data))
  
  #print(accuracy(Arima_Train_Data_Diff %>% forecast(h=length(Test_Data_Diff)), Test_Data_Diff))
  #print(summary(Arima_Train_Data_Diff))
  #Plot_Resid_Arima_Diff <- plot(resid(Arima_Train_Data_Diff))

  #print(accuracy(Sarima_Train_Data %>% forecast(h=length(Test_Data)) , Test_Data))
  #print(summary(Sarima_Train_Data))
  #Plot_Resid_Sarima <- plot(resid(Sarima_Train_Data))
  #print(accuracy(Sarima_Train_Data_Diff %>% forecast(h=length(Test_Data_Diff)), Test_Data_Diff))
  #print(summary(Sarima_Train_Data_Diff))
  #Plot_Resid_Sarima_Diff <- plot(resid(Sarima_Train_Data_Diff))

  #print(accuracy(Holt_ES_Data, Test_Data))
  #Plot_Resid_Holt_ES <- plot(resid(Holt_ES_Data))
  #print(accuracy(Holt_ES_Data_Diff, Test_Data_Diff))
  #Plot_Resid_Holt_ES_Diff <- plot(resid(Holt_ES_Data_Diff))

  #print(accuracy(TBATS_Data %>% forecast(h=length(Test_Data)) , Test_Data))
  #Plot_Resid_TBATS <- plot(resid(TBATS_Data))
  #print(accuracy(TBATS_Data_Diff %>% forecast(h=length(Test_Data_Diff)) , Test_Data_Diff))
  #Plot_Resid_TBATS_Diff <- plot(resid(TBATS_Data_Diff))
  
  #(Plot_Resid_Arima+Plot_Resid_Arima_Diff+Plot_Resid_Sarima+Plot_Resid_Sarima_Diff)/(Plot_Resid_Holt_ES+Plot_Resid_Holt_ES_Diff+Plot_Resid_TBATS+Plot_Resid_TBATS_Diff)
}

```

```{r A,  warning=FALSE}
Funcion_Accuracy_Predicciones_Historicas(BBDD_SP500, SP500_Time_Series, SP500_diferenciado, c(1,1,2), c(1,0,2), c(1,1,2), c(1,0,2), c(0,0,0), c(0,0,0), "Forecasting S&P500 from SARIMA(1,1,2)", "Forecasting S&P500 from SARIMA(1,0,2) with non-zero mean")

Funcion_Accuracy_Predicciones_Historicas(BBDD_DAX, DAX_Time_Series, Dax_diferenciado, c(0,1,0), c(3,0,2), c(0,1,0), c(3,0,2), c(0,1,0,0), c(0,1,0), "Forecasting DAX from SARIMA(0,1,0) ", "Forecasting DAX from SARIMA(3,0,2) with zero mean", c(0,0,0))

Funcion_Accuracy_Predicciones_Historicas(BBDD_HongKongSE, HongKongSE_Time_Series, HK_diferenciado, c(2,1,3), c(3,0,2), c(2,1,3), c(3,0,2), c(0,0,0), c(0,0,0), "Forecasting Kong Kong Stock Exchange from SARIMA(2,1,3) ", "Forecasting Kong Kong Stock Exchange from SARIMA(3,0,2) with non-zero mean") 

Funcion_Accuracy_Predicciones_Historicas(BBDD_Crude_Oil,Crude_Oil_Time_Series, Oil_diferenciado, c(2,1,3), c(2,0,3), c(2,1,3), c(2,0,3), c(0,0,0), c(0,0,0), "Forecasting Crude Oil's Futures from SARIMA(2,1,3) ", "Forecasting Crude Oil's Futures from SARIMA(2,0,3) with zero mean")

Funcion_Accuracy_Predicciones_Historicas(BBDD_Natural_Gas, Natural_Gas_Time_Series, Natgas_diferenciado, c(0,1,0), c(1,0,1), c(0,1,0), c(1,0,1), c(0,0,0), c(0,0,0), "Forecasting Natural Gas Futures from SARIMA(0,1,0) ", "Forecasting Natural Gas Futures from SARIMA(1,0,1) with zero mean")

Funcion_Accuracy_Predicciones_Historicas(BBDD_Gold ,Gold_Time_Series, Gold_diferenciado, c(0,1,0), c(0,0,0), c(0,1,0), c(0,0,0), c(0,0,0), c(0,0,0), "Forecasting Gold's Futures from SARIMA(0,1,0) ", "Forecasting Gold's Futures from SARIMA(0,0,0) with non-zero mean")

Funcion_Accuracy_Predicciones_Historicas(BBDD_Copper, Copper_Time_Series, Copper_diferenciado, c(0,1,1), c(0,0,0), c(0,1,1), c(0,0,0), c(0,0,0), c(0,0,0), "Forecasting Copper's Futures from SARIMA(0,1,1) ", "Forecasting Copper's Futures from SARIMA(0,0,0) with non-zero mean")

Funcion_Accuracy_Predicciones_Historicas(BBDD_EURUSD,EURUSD_Time_Series, EURUSD_diferenciado, c(1,1,1), c(1,0,1), c(1,1,1), c(1,0,1), c(0,0,0), c(0,0,0), "Forecasting EUR/USD from SARIMA(1,1,1) ", "Forecasting EUR/USD from SARIMA(1,0,1) with zero mean")

Funcion_Accuracy_Predicciones_Historicas(BBDD_TY10,TY10_Time_Series, TY10_diferenciado, c(2,1,2), c(0,0,0), c(2,1,2), c(0,0,0), c(0,0,0), c(0,0,0), "Forecasting US Treasury Bonds from SARIMA(2,1,2) ", "Forecasting US Treasury Bonds from SARIMA(0,0,0) with zero mean")

```


###########################################################################
SISTEMA DE INVERSIÓN CON FRECUENCIA DE DATOS DIARIA
###########################################################################

Por problemáticas con ciertos paquetes y su ejecución dentro de funciones, se ha tenido que realizar el código sin pasar por función para cada activo. 

```{r}
library(quantmod)
library(lattice)
library(timeSeries)
library(rugarch)

#arima garch sempre sera vermell
#tbats sempre sera blau
#Holt sempre sera verd 
```

###########################################################################
SISTEMA DE INVERSIÓN CON FRECUENCIA DE DATOS DIARIA
###########################################################################

```{r}
bbdd <- getSymbols("^GSPC", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))

(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("^GDAXI", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("^HSI", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("NG=F", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("GC=F", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))



(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("HG=F", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("EURUSD=X", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("^TNX", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))



(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("CL=F", from="2019-01-01", auto.assign = F) 
bbdd <- na.omit(bbdd)
bbdd <- bbdd[-bbdd$`CL=F.Adjusted`<0,]

AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 200
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

###########################################################################
SISTEMA DE INVERSIÓN CON FRECUENCIA DE DATOS SEMANAL
###########################################################################

```{r}
bbdd <- getSymbols("^GSPC", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))

(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```
```{r}
bbdd <- getSymbols("^GDAXI", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("^HSI", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("NG=F", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("GC=F", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))



(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("HG=F", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("EURUSD=X", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("^TNX", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))



(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("CL=F", from="2019-01-01", auto.assign = F, periodicity = "weekly") 
bbdd <- na.omit(bbdd)
bbdd <- bbdd[-bbdd$`CL=F.Adjusted`<0,]
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 40
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```


###########################################################################
SISTEMA DE INVERSIÓN CON FRECUENCIA DE DATOS MENSUAL
###########################################################################

```{r}
bbdd <- getSymbols("^GSPC", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))

(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("^GDAXI", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("^HSI", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("NG=F", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("GC=F", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))



(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("HG=F", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
bbdd <- getSymbols("EURUSD=X", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

```{r}
 bbdd <- getSymbols("^TNX", from="2019-01-01", auto.assign = F, periodicity = "monthly")
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))  
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))



(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100) 
```

```{r}
bbdd <- getSymbols("^TNX", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)


Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( ultimas_letras[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))



(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```


```{r}
bbdd <- getSymbols("CL=F", from="2019-01-01", auto.assign = F, periodicity = "monthly") 
bbdd <- na.omit(bbdd)
AssetReturns = diff(log(bbdd[,6]))
AssetReturns[as.character(head(index(bbdd[,6]),1))] = 0
  
   
windowLength = 10
foreLength = length(AssetReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)
forecasts2 <- vector(mode="character", length=foreLength) 
forecasts3 <- vector(mode="character", length=foreLength)
  
  for (d in 0:foreLength) {
       
      AssetReturnsOffset = AssetReturns[(1+d):(windowLength+d)]
  
       
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
          if ( p == 0 && q == 0) {
              next
          }
          arimaFit = tryCatch( arima(AssetReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(AssetReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
       
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="sged"
      )
      fit = tryCatch(
        ugarchfit(
          spec, AssetReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
       
       
       
      if(is(fit, "warning")) {
        forecasts[d+1] = paste(index(AssetReturnsOffset[windowLength]), 1, sep=",")
        print(paste(index(AssetReturnsOffset[windowLength]), 1, sep=","))
      } else {
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
        print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
      }
  }
  
 
tbats_model <- tbats(AssetReturns)
 
rolling_mean <- rollapply(AssetReturns, windowLength, mean, fill = NA, align = "right")
 
for (d in 1:foreLength) {
  current_data <- AssetReturns[(d):(windowLength+d-1)] 
  current_mean <- rolling_mean[windowLength+d-1]  
  current_forecast <- forecast(tbats_model, h = 1)$mean  
   
  if (current_forecast > current_mean) {
    signal <- 1
  } else {
    signal <- -1
  }
   
  forecasts2[d] <- paste0(index(AssetReturns)[windowLength+d], ",", signal)
   
  rolling_mean[windowLength+d] <- mean(current_data)
}


 
hw_fit <- HoltWinters(AssetReturns, gamma = FALSE)
for (d in 1:foreLength) {
 
  Training_Data <- tail(AssetReturns, windowLength+d-1)
   
  hw_fore <- predict(hw_fit, n.ahead=1)
  pred <- hw_fore[,1]
   
  mean_return <- mean(tail(Training_Data, windowLength))
   
  if (pred > mean_return) {
    forecasts3[d] <- paste(1)
  } else {
    forecasts3[d] <- paste(-1)
  }
}

#  
write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
write.csv(forecasts2, file="forecasts2.csv", row.names=FALSE)
write.csv(forecasts3, file="forecasts3.csv", row.names=FALSE)

#  
forecasts <- readLines("forecasts.csv")
old_value <- 1
new_list <- c()

for (f in forecasts[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new.csv", "w")
writeLines(new_list, out)
close(out)

#
forecasts2 <- readLines("forecasts2.csv")
old_value <- 1
new_list <- c()

for (f in forecasts2[-1]) {
  strpf <- gsub('"', '', f)
  strpf <- trimws(strpf)
  new_str <- paste(strpf, ",", old_value, "\n", sep = "")
  newspl <- strsplit(new_str, ",")[[1]]
  final_str <- paste(newspl[1], ",", newspl[3], "\n", sep = "")
  final_str <- gsub('"', '', final_str)
  old_value <- trimws(strsplit(f, ",")[[1]][2])
  new_list <- c(new_list, final_str)
 }
out <- file("forecasts_new2.csv", "w")
writeLines(new_list, out)
close(out)

#
  Fechas_Originales <- read.csv("forecasts_new2.csv")
  columna_a_copiar <- Fechas_Originales[,1]
  Señales_3 <- read.csv("forecasts3.csv")
  datos_destino <- Señales_3
  Datos_Holt <- data.frame(columna_a_copiar, Señales_3[-1,])
  write.csv(Datos_Holt, "forecasts_new3.csv", row.names = FALSE)

 
Asset_data = as.xts(read.zoo(file="forecasts_new.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data2 = as.xts(read.zoo(file="forecasts_new2.csv", format="%Y-%m-%d", header=F, sep=","))
Asset_data3 = as.xts(read.zoo(file="forecasts_new3.csv", format="%Y-%m-%d", header=T, sep=","))
   
 
AsstetIntersect = merge( Asset_data[,1], AssetReturns, all=F )
AssetReturnss = AsstetIntersect[,1] * AsstetIntersect[,2]

AsstetIntersect2 = merge( Asset_data2[,1], AssetReturns, all=F )
AssetReturnss2 = AsstetIntersect2[,1] * AsstetIntersect2[,2]  
  
AsstetIntersect3 = merge( Asset_data3[,1], AssetReturns, all=F )
AssetReturnss3 = AsstetIntersect3[,1] * AsstetIntersect3[,2]  

windowLength_1 <- windowLength+1

Asset_BuyHoldCurve = log(cumprod(1+AssetReturns[windowLength_1:length(AssetReturns)]))
AssetCurve = log(cumprod(1+AssetReturnss))
AssetCurve2 = log(cumprod(1+AssetReturnss2))
AssetCurve3 = log(cumprod(1+AssetReturnss3))
Asset_CombinedCurve = merge(AssetCurve, AssetCurve2,AssetCurve3, Asset_BuyHoldCurve, all=F)
  
xyplot(Asset_CombinedCurve,superpose=T,col=c("darkred", "darkblue", "darkgreen", "black"),lwd=2,key=list(text=list(c("Buy & Hold (Negro) / ARIMA+GARCH (Rojo) / TBATS (Azul) / Holt-Winters (Verde)"))))


(buyholdprofit <- sum(AssetReturns[windowLength:length(AssetReturns)])*100)
(arimagarchprofit <- sum(AssetReturnss$Asset_data...1.)*100)
(tbatsprofit<- sum(AssetReturnss2$Asset_data2...1.)*100)
(holtprofit<- sum(AssetReturnss3$Asset_data3...1.)*100)
```

###########################################################################
COMPARACIÓN DE RESULTADOS 
###########################################################################

```{r}
datos <- data.frame(
  Activo = c("S&P500", "S&P500", "S&P500", "Dax", "Dax", "Dax", "Hong Kong SE", "Hong Kong SE", "Hong Kong SE", "Petróleo", "Petróleo", "Petróleo", "NatGas", "NatGas", "NatGas", "Oro", "Oro", "Oro", "Cobre", "Cobre", "Cobre", "EUR/USD", "EUR/USD", "EUR/USD", "Bono USA 10A", "Bono USA 10A", "Bono USA 10A"),
  Temporalidad = c("Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual", "Diario", "Semanal", "Mensual"),
  Buy_Hold = c(31.16, 31.79, 31.79, 23.63, 24.1, 24.1, -29.91, -28.11, -29.91, 30.08, 27.72, 23.6, -7.5, -7.11, -19.34, 31.69, 32.5, 29.43, 38.62, 40.14, 37.51, 0.31, 0.71, 0.69, 65.31, 70.88, 70.88),
  Arima_Garch = c(30.3, 32.25, 32.25, 12.55, 23.34, 24.53, -24.74, -28.76, -28.87, 225.62, 27.72, 23.6, 38.7, -7.11, -19.34, 20.22, 35.4, 28.33, 49.66, 40.14, 37.51, 1.95, 0.71, 0.69, 119.48, 70.88, 70.88),
  TBATS = c(19.6, 44.86, 13.6, 3.81, 1.23, 51.26, 26.39, 30.32, 31.44, -26.91, -70.54, 173.19, 176.24, -48.06, 61.12, 31.25, -32.64, 22.88, -18.33, -8.94, 4.31, -8.23, -21.79, 6.86, 66.62, -125.45, 23.67),
  Holt_Winters = c(-31.08, -32.15, 26.42, -22.17, -23.63, 17.8, 30.29, 29.74, -29.08, -27.98, -28.61, -28.55, -6.6, -4.94, 16.44, 30.70, 30.74, 24.81, -39.28, -37.87, -41.9, -0.55, 0.09, -0.02, -66.1, -67.48, -65.03))
View(datos)

plot(datos$Buy_Hold, col = "black", ylim=c(-150,250),pch = 16, cex = 3, xlab = "Evolución porcentual de los activos")
points(datos$Arima_Garch, col = "red",pch = 16, cex = 2)
points(datos$Holt_Winters, col = "green",pch = 16, cex = 2)
points(datos$TBATS, col = "blue",pch = 16, cex = 2)
abline(v = 1.5, col = "black", lty = "dashed")
abline(v = 2.5, col = "black", lty = "dashed")
abline(v = 3.5, col = "black", lty = "dashed")
abline(v = 4.5, col = "black", lty = "dashed")
abline(v = 5.5, col = "black", lty = "dashed")
abline(v = 6.5, col = "black", lty = "dashed")
abline(v = 7.5, col = "black", lty = "dashed")
abline(v = 8.5, col = "black", lty = "dashed")
abline(v = 9.5, col = "black", lty = "dashed")
abline(v = 10.5, col = "black", lty = "dashed")
abline(v = 11.5, col = "black", lty = "dashed")
abline(v = 12.5, col = "black", lty = "dashed")
abline(v = 13.5, col = "black", lty = "dashed")
abline(v = 14.5, col = "black", lty = "dashed")
abline(v = 15.5, col = "black", lty = "dashed")
abline(v = 16.5, col = "black", lty = "dashed")
abline(v = 17.5, col = "black", lty = "dashed")
abline(v = 18.5, col = "black", lty = "dashed")
abline(v = 19.5, col = "black", lty = "dashed")
abline(v = 20.5, col = "black", lty = "dashed")
abline(v = 21.5, col = "black", lty = "dashed")
abline(v = 22.5, col = "black", lty = "dashed")
abline(v = 23.5, col = "black", lty = "dashed")
abline(v = 24.5, col = "black", lty = "dashed")
abline(v = 25.5, col = "black", lty = "dashed")
abline(v = 26.5, col = "black", lty = "dashed")
legend("topleft", legend = c("var2", "var3"), col = c("red", "blue"), pch = 1)


datos_diarios <- subset(datos, datos$Temporalidad=="Diario")
plot(datos_diarios$Buy_Hold, col = "black", ylim=c(-150,250),pch = 16, cex = 3, ylab = "Evolución porcentual de los activos diarios", xlab="Activos")
points(datos_diarios$Arima_Garch, col = "red",pch = 16, cex = 2)
points(datos_diarios$Holt_Winters, col = "green",pch = 16, cex = 2)
points(datos_diarios$TBATS, col = "blue",pch = 16, cex = 2)
abline(v = 1.5, col = "black", lty = "dashed")
abline(v = 2.5, col = "black", lty = "dashed")
abline(v = 3.5, col = "black", lty = "dashed")
abline(v = 4.5, col = "black", lty = "dashed")
abline(v = 5.5, col = "black", lty = "dashed")
abline(v = 6.5, col = "black", lty = "dashed")
abline(v = 7.5, col = "black", lty = "dashed")
abline(v = 8.5, col = "black", lty = "dashed")


datos_semanales <- subset(datos, datos$Temporalidad=="Semanal")
plot(datos_semanales$Buy_Hold, col = "black", ylim=c(-150,250),pch = 16, cex = 3, ylab = "Evolución porcentual de los activos semanales", xlab="Activos")
points(datos_semanales$Arima_Garch, col = "red",pch = 16, cex = 2)
points(datos_semanales$Holt_Winters, col = "green",pch = 16, cex = 2)
points(datos_semanales$TBATS, col = "blue",pch = 16, cex = 2)
abline(v = 1.5, col = "black", lty = "dashed")
abline(v = 2.5, col = "black", lty = "dashed")
abline(v = 3.5, col = "black", lty = "dashed")
abline(v = 4.5, col = "black", lty = "dashed")
abline(v = 5.5, col = "black", lty = "dashed")
abline(v = 6.5, col = "black", lty = "dashed")
abline(v = 7.5, col = "black", lty = "dashed")
abline(v = 8.5, col = "black", lty = "dashed")

datos_mensuales <- subset(datos, datos$Temporalidad=="Mensual")
plot(datos_mensuales$Buy_Hold, col = "black", ylim=c(-150,250),pch = 16, cex = 3,ylab="Evolución porcentual de los activos mensuales", xlab="Activos")
points(datos_mensuales$Arima_Garch, col = "red",pch = 16, cex = 2)
points(datos_mensuales$Holt_Winters, col = "green",pch = 16, cex = 2)
points(datos_mensuales$TBATS, col = "blue",pch = 16, cex = 2)
abline(v = 1.5, col = "black", lty = "dashed")
abline(v = 2.5, col = "black", lty = "dashed")
abline(v = 3.5, col = "black", lty = "dashed")
abline(v = 4.5, col = "black", lty = "dashed")
abline(v = 5.5, col = "black", lty = "dashed")
abline(v = 6.5, col = "black", lty = "dashed")
abline(v = 7.5, col = "black", lty = "dashed")
abline(v = 8.5, col = "black", lty = "dashed")

Datos_Distancias_ARIMA <- datos$Arima_Garch-datos$Buy_Hold
Datos_Distancias_TBATS <- datos$TBATS-datos$Buy_Hold
Datos_Distancias_Holt <- datos$Holt_Winters-datos$Buy_Hold
Datos_Distancias <-cbind(datos,Datos_Distancias_ARIMA, Datos_Distancias_TBATS, Datos_Distancias_Holt)

Datos_Distancias_Diario <- subset(Datos_Distancias, Datos_Distancias$Temporalidad=="Diario")
plot(Datos_Distancias_Diario$Datos_Distancias_ARIMA, col = "red", ylim=c(-150,250),pch = 16, cex = 2, ylab="Diferencia porcentual respecto a Buy&Hold", xlab="Activos diarios")
points(Datos_Distancias_Diario$Datos_Distancias_Holt, col = "green",pch = 16, cex = 2)
points(Datos_Distancias_Diario$Datos_Distancias_TBATS, col = "blue",pch = 16, cex = 2)
abline(h = 0, col = "black")
abline(v = 1.5, col = "black", lty = "dashed")
abline(v = 2.5, col = "black", lty = "dashed")
abline(v = 3.5, col = "black", lty = "dashed")
abline(v = 4.5, col = "black", lty = "dashed")
abline(v = 5.5, col = "black", lty = "dashed")
abline(v = 6.5, col = "black", lty = "dashed")
abline(v = 7.5, col = "black", lty = "dashed")
abline(v = 8.5, col = "black", lty = "dashed")
mean(datos_diarios$Buy_Hold)
mean(datos_diarios$Arima_Garch)
mean(datos_diarios$TBATS)
mean(datos_diarios$Holt_Winters)

Datos_Distancias_Semanal <- subset(Datos_Distancias, Datos_Distancias$Temporalidad=="Semanal")
plot(Datos_Distancias_Semanal$Datos_Distancias_ARIMA, col = "red", ylim=c(-150,250),pch = 16, cex = 2, ylab = "Diferencia porcentual respecto a Buy&Hold", xlab="Activos semanales")
points(Datos_Distancias_Semanal$Datos_Distancias_Holt, col = "green",pch = 16, cex = 2)
points(Datos_Distancias_Semanal$Datos_Distancias_TBATS, col = "blue",pch = 16, cex = 2)
abline(h = 0, col = "black")
abline(v = 1.5, col = "black", lty = "dashed")
abline(v = 2.5, col = "black", lty = "dashed")
abline(v = 3.5, col = "black", lty = "dashed")
abline(v = 4.5, col = "black", lty = "dashed")
abline(v = 5.5, col = "black", lty = "dashed")
abline(v = 6.5, col = "black", lty = "dashed")
abline(v = 7.5, col = "black", lty = "dashed")
abline(v = 8.5, col = "black", lty = "dashed")
mean(datos_semanales$Buy_Hold)
mean(datos_semanales$Arima_Garch)
mean(datos_semanales$TBATS)
mean(datos_semanales$Holt_Winters)

Datos_Distancias_Mensual <- subset(Datos_Distancias, Datos_Distancias$Temporalidad=="Mensual")
plot(Datos_Distancias_Mensual$Datos_Distancias_ARIMA, col = "red", ylim=c(-150,250),pch = 16, cex = 2,  ylab = "Diferencia porcentual respecto a Buy&Hold",xlab="Activos mensuales")
points(Datos_Distancias_Mensual$Datos_Distancias_Holt, col = "green",pch = 16, cex = 2)
points(Datos_Distancias_Mensual$Datos_Distancias_TBATS, col = "blue",pch = 16, cex = 2)
abline(h = 0, col = "black")
abline(v = 1.5, col = "black", lty = "dashed")
abline(v = 2.5, col = "black", lty = "dashed")
abline(v = 3.5, col = "black", lty = "dashed")
abline(v = 4.5, col = "black", lty = "dashed")
abline(v = 5.5, col = "black", lty = "dashed")
abline(v = 6.5, col = "black", lty = "dashed")
abline(v = 7.5, col = "black", lty = "dashed")
abline(v = 8.5, col = "black", lty = "dashed")
mean(datos_mensuales$Buy_Hold)
mean(datos_mensuales$Arima_Garch)
mean(datos_mensuales$TBATS)
mean(datos_mensuales$Holt_Winters)
```
